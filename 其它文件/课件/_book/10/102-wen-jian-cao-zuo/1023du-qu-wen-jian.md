## **读取文件**

### **Read 读取文件**

如果文件已经存在，并且也已经有数据了，那么可以直接读取该文件中的内容。

读取文件的基本流程如下：

（1）打开要读取的文件

（2）对文件进行读取

（3）关闭文件

在向文件中写数据的时候，使用的是Write,那么读取文件中的数据，使用的是Read.

关于Read\( \)函数的使用如下：

```go
package main

import (
    "fmt"
    "io"
    "os"
)
func main() {

    //打开文件
    fp, err := os.Open("D:/a.txt")
    if err != nil {
        fmt.Println("err=", err)
        return
    }

    buf := make([]byte, 1024*2) //2k大小
    //n代表从文件读取内容的长度
    n, err1 := fp.Read(buf)
    if err1 != nil && err1 != io.EOF {
        fmt.Println("err1=", err1)
        return
    }
    fmt.Println("buf=", string(buf[:n]))

    //关闭文件
    defer fp.Close()

}
```

Open\( \)是打开文件，与OpenFile\( \)的区别是，Open\( \)只有读的权限

在使用Read\( \)函数读取文件中的内容时，需要一个切片类型，而定义切片时类型为字符数组，将文件中的内容保存在切片中，同时除了对其判断是否出错时以外，还要判断是否到文件末尾\(这里需要导入io包\)。

Read\( \)函数返回的是从文件中读取的数据的长度。最后，输出切片中存储的文件数据，注意，读取的是从最开始到整个数据长度，因为有可能存储到切片中的数据达不到切片的总长度（也是切片时2k,但是从文件中读取的数据有可能只有1k）

### **按行读取**

上面我们是将文件的内容全部读取出来，然后存放在切片中，我们也可以每次只读取一行数据。

这需要用到bufio包中的ReadBytes函数。具体如下：

1：打开文件

```go
fp, err := os.Open("D:/a.txt")
if err != nil {
    fmt.Println("打开文件失败", err)
    return
}
```

2：创建缓冲区

在使用ReadBytes\( \)函数读取数据时，需要用到缓冲区,所谓缓冲区就是存储数据的区域，也就是先将从文件中读取的数据存储在该区域内，然后在将区域中的数据取出来，写到磁盘上。提供缓冲区的原因是：

为了缓和 CPU 与磁盘设备之间速度不匹配矛盾。文件缓冲区是用以暂时存放读写期间的文件数据而在内存区预留的一定空间。

```go
//创建文件缓冲区
r := bufio.NewReader(fp)
```

3：循环读取文件中的内容，直到文件末尾位置。

```go
for {
    //遇到'\n'结束读取，但是'\n'也读取进入
    buf,err := r.ReadBytes('\n')
    fmt.Println("buf = ",string(buf))
    if err != nil {
        if err == io.EOF {
            break
        }
        fmt.Println("err=",err)
    }
}
```

在使用ReadBytes\( \)函数时，传递的参数是‘\n’,表示遇到’\n’就结束，所以使用了死循环（每循环一次，读取一行数据），只有到文件末尾了，才退出整个循环。最后，将读取的数据打印出来，注意ReadBytes\( \)返回的是字节切片，所以在打印时要转换成字符串。

4：最后关闭文件

```go
//关闭文件
defer fp.Close()
```

现在我们已经完成了文件的创建，读取，以及将数据保存到文件的操作，在对文件操作时，我们需要指定文件的路径。

**关于路径，有两种情况：**

第一：相对路径，所谓相对路径指的是文件相对于应用程序的路径。例如：上面我们一只使用的a.txt,这个文件，该文件存放的位置与可执行文件存储的路径是一样的。

第二：绝对路径：指的是通过给定的这个路径直接能在我的电脑中找到这个文件。例如：D:\Info.txt,

* **建议我们以后在开发中使用相对路径**



